# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, pyusb
# This file is distributed under the same license as the pyusb-docs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: pyusb-docs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-08-29 09:22+0900\n"
"PO-Revision-Date: 2020-05-02 04:36+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../autoapi/usb/util/index.rst:2
msgid ":py:mod:`usb.util`"
msgstr ""

#: ../../autoapi/usb/util/index.rst:6
msgid "usb.util - Utility functions."
msgstr "usb.util - ユーティリティ関数群。"

#: ../../autoapi/usb/util/index.rst:8
msgid "This module exports:"
msgstr "本モジュールからは以下がエスクポートされます:"

#: ../../autoapi/usb/util/index.rst:10
msgid "endpoint_address - return the endpoint absolute address."
msgstr ""

#: ../../autoapi/usb/util/index.rst:11
msgid "endpoint_direction - return the endpoint transfer direction."
msgstr ""

#: ../../autoapi/usb/util/index.rst:12
msgid "endpoint_type - return the endpoint type"
msgstr ""

#: ../../autoapi/usb/util/index.rst:13
msgid "ctrl_direction - return the direction of a control transfer"
msgstr ""

#: ../../autoapi/usb/util/index.rst:14
msgid "build_request_type - build a bmRequestType field of a control transfer."
msgstr ""

#: ../../autoapi/usb/util/index.rst:15
msgid "find_descriptor - find an inner descriptor."
msgstr ""

#: ../../autoapi/usb/util/index.rst:16
msgid "claim_interface - explicitly claim an interface."
msgstr ""

#: ../../autoapi/usb/util/index.rst:17
msgid "release_interface - explicitly release an interface."
msgstr ""

#: ../../autoapi/usb/util/index.rst:18
msgid "dispose_resources - release internal resources allocated by the object."
msgstr ""

#: ../../autoapi/usb/util/index.rst:19
msgid ""
"get_langids - retrieve the list of supported string languages from the "
"device."
msgstr ""

#: ../../autoapi/usb/util/index.rst:20
msgid "get_string - retrieve a string descriptor from the device."
msgstr ""

#: ../../autoapi/usb/util/index.rst:25
#, fuzzy
#| msgid "Module contents"
msgid "Module Contents"
msgstr "モジュール内容"

#: ../../autoapi/usb/util/index.rst:29
msgid "Functions"
msgstr ""

#: ../../autoapi/usb/util/index.rst:31
msgid "usb.util.endpoint_address"
msgstr ""

#: ../../autoapi/usb/util/index.rst:32
msgid "usb.util.endpoint_direction"
msgstr ""

#: ../../autoapi/usb/util/index.rst:33
msgid "usb.util.endpoint_type"
msgstr ""

#: ../../autoapi/usb/util/index.rst:34
#, fuzzy
#| msgid "usb.util - Utility functions."
msgid "usb.util.ctrl_direction"
msgstr "usb.util - ユーティリティ関数群。"

#: ../../autoapi/usb/util/index.rst:35
msgid "usb.util.build_request_type"
msgstr ""

#: ../../autoapi/usb/util/index.rst:36
msgid "usb.util.create_buffer"
msgstr ""

#: ../../autoapi/usb/util/index.rst:37
msgid "usb.util.find_descriptor"
msgstr ""

#: ../../autoapi/usb/util/index.rst:38
msgid "usb.util.claim_interface"
msgstr ""

#: ../../autoapi/usb/util/index.rst:39
msgid "usb.util.release_interface"
msgstr ""

#: ../../autoapi/usb/util/index.rst:40
msgid "usb.util.dispose_resources"
msgstr ""

#: ../../autoapi/usb/util/index.rst:41
msgid "usb.util.get_langids"
msgstr ""

#: ../../autoapi/usb/util/index.rst:42
msgid "usb.util.get_string"
msgstr ""

#: ../../autoapi/usb/util/index.rst:47
msgid "Attributes"
msgstr ""

#: ../../autoapi/usb/util/index.rst:211
msgid "Return the endpoint absolute address."
msgstr ""

#: ../../autoapi/usb/util/index.rst:213
msgid ""
"The address parameter is the bEndpointAddress field of the endpoint "
"descriptor."
msgstr ""

#: ../../autoapi/usb/util/index.rst:219
msgid "Return the endpoint direction."
msgstr ""

#: ../../autoapi/usb/util/index.rst:221
msgid ""
"The address parameter is the bEndpointAddress field of the endpoint "
"descriptor. The possible return values are ENDPOINT_OUT or ENDPOINT_IN."
msgstr ""

#: ../../autoapi/usb/util/index.rst:228
msgid "Return the transfer type of the endpoint."
msgstr ""

#: ../../autoapi/usb/util/index.rst:230
msgid ""
"The bmAttributes parameter is the bmAttributes field of the endpoint "
"descriptor. The possible return values are: ENDPOINT_TYPE_CTRL, "
"ENDPOINT_TYPE_ISO, ENDPOINT_TYPE_BULK or ENDPOINT_TYPE_INTR."
msgstr ""

#: ../../autoapi/usb/util/index.rst:238
msgid "Return the direction of a control request."
msgstr ""

#: ../../autoapi/usb/util/index.rst:240
msgid ""
"The bmRequestType parameter is the value of the bmRequestType field of a "
"control transfer. The possible return values are CTRL_OUT or CTRL_IN."
msgstr ""

#: ../../autoapi/usb/util/index.rst:247
msgid "Build a bmRequestType field for control requests."
msgstr ""

#: ../../autoapi/usb/util/index.rst:249
msgid ""
"These is a conventional function to build a bmRequestType for a control "
"request."
msgstr ""

#: ../../autoapi/usb/util/index.rst:252
msgid ""
"The direction parameter can be CTRL_OUT or CTRL_IN. The type parameter can "
"be CTRL_TYPE_STANDARD, CTRL_TYPE_CLASS, CTRL_TYPE_VENDOR or "
"CTRL_TYPE_RESERVED values. The recipient can be CTRL_RECIPIENT_DEVICE, "
"CTRL_RECIPIENT_INTERFACE, CTRL_RECIPIENT_ENDPOINT or CTRL_RECIPIENT_OTHER."
msgstr ""

#: ../../autoapi/usb/util/index.rst:258
msgid "Return the bmRequestType value."
msgstr ""

#: ../../autoapi/usb/util/index.rst:263
msgid "Create a buffer to be passed to a read function."
msgstr ""

#: ../../autoapi/usb/util/index.rst:265
msgid ""
"A read function may receive an out buffer so the data is read inplace and "
"the object can be reused, avoiding the overhead of creating a new object at "
"each new read call. This function creates a compatible sequence buffer of "
"the given length."
msgstr ""

#: ../../autoapi/usb/util/index.rst:274
msgid "Find an inner descriptor."
msgstr ""

#: ../../autoapi/usb/util/index.rst:276
msgid ""
"find_descriptor works in the same way as the core.find() function does, but "
"it acts on general descriptor objects. For example, suppose you have a "
"Device object called dev and want a Configuration of this object with its "
"bConfigurationValue equals to 1, the code would be like so:"
msgstr ""

#: ../../autoapi/usb/util/index.rst:284
msgid ""
"You can use any field of the Descriptor as a match criteria, and you can "
"supply a customized match just like core.find() does. The find_descriptor "
"function also accepts the find_all parameter to get an iterator instead of "
"just one descriptor."
msgstr ""

#: ../../autoapi/usb/util/index.rst:292
msgid "Explicitly claim an interface."
msgstr ""

#: ../../autoapi/usb/util/index.rst:294
msgid ""
"PyUSB users normally do not have to worry about interface claiming, as the "
"library takes care of it automatically. But there are situations where you "
"need deterministic interface claiming. For these uncommon cases, you can use "
"claim_interface."
msgstr ""

#: ../../autoapi/usb/util/index.rst:299
msgid ""
"If the interface is already claimed, either through a previously call to "
"claim_interface or internally by the device object, nothing happens."
msgstr ""

#: ../../autoapi/usb/util/index.rst:305
msgid "Explicitly release an interface."
msgstr ""

#: ../../autoapi/usb/util/index.rst:307
msgid ""
"This function is used to release an interface previously claimed, either "
"through a call to claim_interface or internally by the device object."
msgstr ""

#: ../../autoapi/usb/util/index.rst:311
msgid ""
"Normally, you do not need to worry about claiming policies, as the device "
"object takes care of it automatically."
msgstr ""

#: ../../autoapi/usb/util/index.rst:317
msgid "Release internal resources allocated by the object."
msgstr ""

#: ../../autoapi/usb/util/index.rst:319
msgid ""
"Sometimes you need to provide deterministic resources freeing, for example "
"to allow another application to talk to the device. As Python does not "
"provide deterministic destruction, this function releases all internal "
"resources allocated by the device, like device handle and interface policy."
msgstr ""

#: ../../autoapi/usb/util/index.rst:326
msgid ""
"After calling this function, you can continue using the device object "
"normally. If the resources will be necessary again, it will be allocated "
"automatically."
msgstr ""

#: ../../autoapi/usb/util/index.rst:333
msgid "Retrieve the list of supported Language IDs from the device."
msgstr ""

#: ../../autoapi/usb/util/index.rst:335
msgid ""
"Most client code should not call this function directly, but instead use the "
"langids property on the Device object, which will call this function as "
"needed and cache the result."
msgstr ""

#: ../../autoapi/usb/util/index.rst:339
msgid ""
"USB LANGIDs are 16-bit integers familiar to Windows developers, where for "
"example instead of en-US you say 0x0409. See the file USB_LANGIDS.pdf "
"somewhere on the usb.org site for a list, which does not claim to be "
"complete. It requires \"system software must allow the enumeration and "
"selection of LANGIDs that are not currently on this list.\" It also requires "
"\"system software should never request a LANGID not defined in the LANGID "
"code array (string index = 0) presented by a device.\" Client code can check "
"this tuple before issuing string requests for a specific language ID."
msgstr ""

#: ../../autoapi/usb/util/index.rst:348
msgid ""
"dev is the Device object whose supported language IDs will be retrieved."
msgstr ""

#: ../../autoapi/usb/util/index.rst:350
msgid ""
"The return value is a tuple of integer LANGIDs, possibly empty if the device "
"does not support strings at all (which USB 3.1 r1.0 section 9.6.9 allows). "
"In that case client code should not request strings at all."
msgstr ""

#: ../../autoapi/usb/util/index.rst:354
msgid ""
"A USBError may be raised from this function for some devices that have no "
"string support, instead of returning an empty tuple. The accessor for the "
"langids property on Device catches that case and supplies an empty tuple, so "
"client code can ignore this detail by using the langids property instead of "
"directly calling this function."
msgstr ""

#: ../../autoapi/usb/util/index.rst:363
msgid "Retrieve a string descriptor from the device."
msgstr ""

#: ../../autoapi/usb/util/index.rst:365
msgid "dev is the Device object which the string will be read from."
msgstr ""

#: ../../autoapi/usb/util/index.rst:367
msgid ""
"index is the string descriptor index and langid is the Language ID of the "
"descriptor. If langid is omitted, the string descriptor of the first "
"Language ID will be returned."
msgstr ""

#: ../../autoapi/usb/util/index.rst:371
msgid ""
"Zero is never the index of a real string. The USB spec allows a device to "
"use zero in a string index field to indicate that no string is provided. So "
"the caller does not have to treat that case specially, this function returns "
"None if passed an index of zero, and generates no traffic to the device."
msgstr ""

#: ../../autoapi/usb/util/index.rst:377
msgid ""
"The return value is the unicode string present in the descriptor, or None if "
"the requested index was zero."
msgstr ""

#~ msgid "usb package"
#~ msgstr "usb パッケージ"

#~ msgid "Subpackages"
#~ msgstr "サブパッケージ"

#~ msgid "Submodules"
#~ msgstr "サブモジュール"

#~ msgid "usb.control module"
#~ msgstr "usb.control モジュール"

#~ msgid "usb.control - USB standard control requests"
#~ msgstr "usb.control - USB 標準制御要求(standard control requests)"

#~ msgid ""
#~ "get_status - get recipeint status clear_feature - clear a recipient "
#~ "feature set_feature - set a recipient feature get_descriptor - get a "
#~ "device descriptor set_descriptor - set a device descriptor "
#~ "get_configuration - get a device configuration set_configuration - set a "
#~ "device configuration get_interface - get a device interface set_interface "
#~ "- set a device interface"
#~ msgstr ""
#~ "get_status - 受信者(recipeint)ステータスの取得、 clear_feature - 受信者"
#~ "(recipient)機能(feature)のクリア、 set_feature - 受信者(recipient)機能"
#~ "(feature)の設定、 get_descriptor - デバイス・デスクリプタ取得、 "
#~ "set_descriptor - デバイス・デスクリプタ設定、 get_configuration - デバイス"
#~ "構成(configuration)の取得、 set_configuration - デバイス構成"
#~ "(configuration)の設定 get_interface - デバイス・インターフェイス取得、 "
#~ "set_interface - デバイス・インターフェイス設定"

#~ msgid "Return the status for the specified recipient."
#~ msgstr "指定の受信者(recipient)のステータスを返す。"

#~ msgid "dev is the Device object to which the request will be sent to."
#~ msgstr "dev は、リクエストの送信先となるデバイス・オブジェクトです。"

#~ msgid ""
#~ "The recipient can be None (on which the status will be queried from the "
#~ "device), an Interface or Endpoint descriptors."
#~ msgstr ""
#~ "受信者(recipient)は、 None (デバイスからステータスが照会される) または "
#~ "Interface または Endpoint デスクリプタにすることができます。"

#~ msgid ""
#~ "The status value is returned as an integer with the lower word being the "
#~ "two bytes status value."
#~ msgstr ""
#~ "ステータス値は整数として返され、下位ワードは2バイトのステータス値からなり"
#~ "ます。"

#~ msgid "Clear/disable a specific feature."
#~ msgstr "指定の機能(feature)をクリアまたは無効にします。"

#~ msgid "feature is the feature you want to disable."
#~ msgstr "featureには、あなたが無効にしたい機能(feature)を指定します。"

#~ msgid "Set/enable a specific feature."
#~ msgstr "指定の機能(feature)を設定または有効化します。"

#~ msgid "feature is the feature you want to enable."
#~ msgstr "featureにはあなたが有効にしたい機能(feature)を指定します。"

#~ msgid "Return the specified descriptor."
#~ msgstr "指定のデスクリプタを返す。"

#~ msgid "desc_size is the descriptor size."
#~ msgstr "desc_sizeはデスクリプタのサイズを指定します。"

#~ msgid ""
#~ "desc_type and desc_index are the descriptor type and index, respectively. "
#~ "wIndex index is used for string descriptors and represents the Language "
#~ "ID. For other types of descriptors, it is zero."
#~ msgstr ""
#~ "desc_typeとdesc_indexは、それぞれデスクリプタのタイプとインデックスです。 "
#~ "wIndexインデックスは文字列デスクリプタに使用され、言語IDを表します。文字列"
#~ "デスクリプタ以外タイプの記述子の場合、wIndexはゼロです。"

#~ msgid "Update an existing descriptor or add a new one."
#~ msgstr ""
#~ "存在するデスクリプタを更新するか、または新しいデスクリプタを追加します。"

#~ msgid ""
#~ "The desc parameter is the descriptor to be sent to the device. desc_type "
#~ "and desc_index are the descriptor type and index, respectively. wIndex "
#~ "index is used for string descriptors and represents the Language ID. For "
#~ "other types of descriptors, it is zero."
#~ msgstr ""
#~ "descほげほげなパラメータ達は、デバイスに送信されるデスクリプタです。 "
#~ "desc_typeとdesc_indexは、それぞれデスクリプタのタイプとインデックスです。 "
#~ "wIndexインデックスは文字列デスクリプタに使用され、言語IDを表します。 文字"
#~ "列デスクリプタ以外のタイプのデスクリプタの場合、wIndexはゼロです。"

#~ msgid "Get the current active configuration of the device."
#~ msgstr ""
#~ "デバイスの、当座(current)でアクティブな構成(configuration)を取得します。"

#~ msgid ""
#~ "This function differs from the Device.get_active_configuration method "
#~ "because the later may use cached data, while this function always does a "
#~ "device request."
#~ msgstr ""
#~ "キャッシュされたデータを使用する可能性がある Device."
#~ "get_active_configuration メソッドとは異なり、この関数は常にデバイス・リク"
#~ "エストを実行します。"

#~ msgid "Set the current device configuration."
#~ msgstr "当座(current)とする構成(configuration)を設定します。"

#~ msgid "Get the current alternate setting of the interface."
#~ msgstr ""
#~ "インターフェイスの代替設定(alternate setting)の当座(current)を取得します。"

#~ msgid "Set the alternate setting of the interface."
#~ msgstr "インターフェイスの代替設定(alternate setting)を設定します。"

#~ msgid "usb.core module"
#~ msgstr "usb.core モジュール"

#~ msgid "usb.core - Core USB features."
#~ msgstr "usb.core - コアUSB機能"

#~ msgid ""
#~ "Device - a class representing a USB device. Configuration - a class "
#~ "representing a configuration descriptor. Interface - a class representing "
#~ "an interface descriptor. Endpoint - a class representing an endpoint "
#~ "descriptor. find() - a function to find USB devices. show_devices() - a "
#~ "function to show the devices present."
#~ msgstr ""
#~ "Device - USBデバイスを表すクラス、 Configuration - 構成(configuration)デス"
#~ "クリプタを表すクラス、 Interface - インターフェイス・デスクリプタを表すク"
#~ "ラス、 Endpoint - エンドポイント・デスクリプタを表すクラス、 find() - USB"
#~ "デバイスを探す関数、show_devices() - 存在するデバイスを表示する関数"

#~ msgid "Bases: :class:`usb._objfinalizer.AutoFinalizedObject`"
#~ msgstr "Bases: :class:`usb._objfinalizer.AutoFinalizedObject`"

#~ msgid "Device object."
#~ msgstr "Deviceオブジェクトです。"

#~ msgid ""
#~ "This class contains all fields of the Device Descriptor according to the "
#~ "USB Specification. You may access them as class properties.  For example, "
#~ "to access the field bDescriptorType of the device descriptor, you can do "
#~ "so:"
#~ msgstr ""
#~ "このクラスには、USB仕様に基づくデバイス・デスクリプタのすべてのフィールド"
#~ "が含まれています。 あなたはそれらにクラスのプロパティとしてアクセスできま"
#~ "す。 たとえば、デバイス・デスクリプタのフィールドbDescriptorTypeにアクセス"
#~ "するには、次のようにします:"

#~ msgid ""
#~ "Additionally, the class provides methods to communicate with the "
#~ "hardware. Typically, an application will first call the "
#~ "set_configuration() method to put the device in a known configured state, "
#~ "optionally call the set_interface_altsetting() to select the alternate "
#~ "setting (if there is more than one) of the interface used, and call the "
#~ "write() and read() methods to send and receive data, respectively."
#~ msgstr ""
#~ "さらに、クラスはハードウェアと通信するメソッドを提供します。 通常、アプリ"
#~ "ケーションは最初にset_configuration()メソッドを呼び出してデバイスを既知の"
#~ "構成済み状態(a known conifgured state)にし、代替設定が複数ある場合、オプ"
#~ "ションでset_interface_altsetting()を呼び出して、使用するインターフェイスの"
#~ "代替設定を選択し、 write() や read() メソッドでデータを送受信します。"

#~ msgid "When working in a new hardware, the first try could be like this:"
#~ msgstr "新しいハードウェアで作業する場合、最初の試行は次のようになります:"

#~ msgid ""
#~ "This sample finds the device of interest (myVendorId and myProductId "
#~ "should be replaced by the corresponding values of your device), then "
#~ "configures the device (by default, the configuration value is 1, which is "
#~ "a typical value for most devices) and then writes some data to the "
#~ "endpoint 0x01."
#~ msgstr ""
#~ "このサンプルでは、対象のデバイスを見つけ（myVendorIdおよびmyProductIdをデ"
#~ "バイスの対応する値で置き換える必要があります）、デバイスを構成し（デフォル"
#~ "トでは、構成値(configuration value)は1であり、ほとんどのデバイスの一般的な"
#~ "値です）、エンドポイント0x01へデータを幾つか書き込みます。"

#~ msgid ""
#~ "Timeout values for the write, read and ctrl_transfer methods are "
#~ "specified in miliseconds. If the parameter is omitted, Device."
#~ "default_timeout value will be used instead. This property can be set by "
#~ "the user at anytime."
#~ msgstr ""
#~ "書き込み、読み取り、およびctrl_transferメソッドのタイムアウト値はミリ秒単"
#~ "位で指定します。このパラメーターを省略した場合、代わりにDevice."
#~ "default_timeout値が使用されます。Device.default_timeoutプロパティは、ユー"
#~ "ザがいつでも設定できます。"

#~ msgid ""
#~ "Re-attach an interface's kernel driver, which was previously detached "
#~ "using detach_kernel_driver()."
#~ msgstr ""
#~ "以前にdetach_kernel_driver()を使って切り離し(detach)した、指定のインター"
#~ "フェイスのカーネル・ドライバを再接続(re-attach)します。"

#~ msgid ""
#~ "The interface parameter is the device interface number to attach the "
#~ "driver to."
#~ msgstr ""
#~ "interface パラメータは、ドライバを接続したい、デバイスのインターフェイス番"
#~ "号を指定します。"

#~ msgid "Return the backend being used by the device."
#~ msgstr "そのデバイスが使っているバックエンドを返します。"

#~ msgid "Clear the halt/stall condition for the endpoint ep."
#~ msgstr "epに指定したエンドポイントの halt/stall 状態をクリアします。"

#~ msgid "Return a tuple of the device configurations."
#~ msgstr "そのデバイスの構成群をタプルで返します。"

#~ msgid "Do a control transfer on the endpoint 0."
#~ msgstr "エンドポイント0で制御転送(control transfer)を行います。"

#~ msgid ""
#~ "This method is used to issue a control transfer over the endpoint 0 "
#~ "(endpoint 0 is required to always be a control endpoint)."
#~ msgstr ""
#~ "このメソッドは、エンドポイント0を介して制御転送を発行するために使用します"
#~ "（エンドポイント0は常に制御エンドポイントである必要があります）。"

#~ msgid ""
#~ "The parameters bmRequestType, bRequest, wValue and wIndex are the same of "
#~ "the USB Standard Control Request format."
#~ msgstr ""
#~ "パラメータbmRequestType、bRequest、wValue、wIndexは、USB標準制御要求"
#~ "(Standard Control Request)フォーマットと同じです。"

#~ msgid "usb.legacy module"
#~ msgstr "usb.legacy モジュール"

#~ msgid "usb.libloader module"
#~ msgstr "usb.libloader モジュール"

#~ msgid "usb.util module"
#~ msgstr "usb.util モジュール"

#~ msgid "PyUSB - Easy USB access in Python"
#~ msgstr "PyUSB - Pythonから簡単にUSBにアクセスできるようにします。"

#~ msgid "This package exports the following modules and subpackages:"
#~ msgstr "本パッケージはイカのモジュールとサブバッケージをエクスポートします:"

#~ msgid ""
#~ "core - the main USB implementation legacy - the compatibility layer with "
#~ "0.x version backend - the support for backend implementations. control - "
#~ "USB standard control requests. libloader - helper module for backend "
#~ "library loading."
#~ msgstr ""
#~ "core - 主たるUSB実装、 legacy - 0.xバージョン利用者互換レイヤ、backend - "
#~ "バックエンド実装のサポート、 control - USB標準制御要求(standard control "
#~ "requests)、 libloader - バックエンドライブラリ読み込みのためのヘルパーモ"
#~ "ジュール"

#~ msgid ""
#~ "Since version 1.0, main PyUSB implementation lives in the 'usb.core' "
#~ "module. New applications are encouraged to use it."
#~ msgstr ""
#~ "バージョン1.0以降では、メインのPyUSB実装は「usb.core」モジュールにありま"
#~ "す。 新しいアプリケーションではそれを使用することをお勧めします。"
