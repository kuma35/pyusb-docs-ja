# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, pyusb
# This file is distributed under the same license as the pyusb-docs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: pyusb-docs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-08-31 14:12+0900\n"
"PO-Revision-Date: 2021-08-31 15:04+0900\n"
"Last-Translator: kuma35\n"
"Language: ja_JP\n"
"Language-Team: Japanese\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../tutorial.rst:3
msgid "Programming with PyUSB 1.0"
msgstr "PyUSB 1.0 を使ってプログラミング"

#: ../../tutorial.rst:6
msgid "Let me introduce myself"
msgstr "手前味噌ですが…"

#: ../../tutorial.rst:8
msgid ""
"PyUSB 1.0 is a Python_ library allowing easy USB_ access. PyUSB provides "
"several features:"
msgstr "PyUSB 1.0は、容易なる USB_ アクセスを可能にする Python_ ライブラリです。 PyUSBはいくつかの機能を提供します:"

#: ../../tutorial.rst:13
msgid "100% written in Python:"
msgstr "100% Python で書かれています:"

#: ../../tutorial.rst:12
msgid ""
"Unlike the 0.x version, which is written in C, 1.0 version is written in "
"Python. This allows Python programmers with no background in C to "
"understand better how PyUSB works."
msgstr ""
"Cで記述された0.xバージョンとは異なり、1.0バージョンはPythonで記述されています。 "
"これにより、CのバックグラウンドがないPythonプログラマーはPyUSBがどのように機能するかをよりよく理解できます。"

#: ../../tutorial.rst:19
msgid "Platform neutrality:"
msgstr "特定のプラットフォームに偏らず、中立です:"

#: ../../tutorial.rst:16
msgid ""
"1.0 version implements a frontend-backend scheme. This isolates the API "
"from system specific implementation details. The glue between the two "
"layers is the ``IBackend`` interface. PyUSB comes with builtin backends "
"for libusb 1.0, libusb 0.1 and OpenUSB.  You can write your own backend "
"if you desire to."
msgstr ""
"1.0バージョンは、フロントエンド-バックエンド スキーム 実装です。 これにより、システム固有の実装の詳細とAPIが分離されています。 "
"2つの層の間の接着剤は ``IBackend`` インターフェースです。 PyUSBには、libusb 1.0、libusb "
"0.1、OpenUSB用の組み込みバックエンドが付属しています。 必要に応じて、独自のバックエンドを作成することもできます。"

#: ../../tutorial.rst:22
msgid "Portability:"
msgstr "ポータビリティ:"

#: ../../tutorial.rst:22
msgid ""
"PyUSB should run on any platform with Python >= 3.6, ctypes_ and at least"
" one of the supported builtin backends."
msgstr "PyUSBは、Python>=3.6 かつ ctypes_ かつ サポートされている組み込みバックエンドの少なくとも1つを備えたすべてのプラットフォームで実行可能です。"

#: ../../tutorial.rst:25
msgid "Easiness:"
msgstr "最強に簡単:"

#: ../../tutorial.rst:25
msgid ""
"Communicating with an USB_ device has never been so easy! USB is a "
"complex protocol, but PyUSB has good defaults for most common "
"configurations."
msgstr ""
"USB_ デバイスとの通信がこれまでになく簡単になりました。 "
"USBは複雑なプロトコルですが、PyUSBにはほとんどの一般的な構成に適したデフォルトの構成があります。"

#: ../../tutorial.rst:28
msgid "Support for isochronous transfers:"
msgstr "アイソクロナス転送(isochronous transfers)のサポート:"

#: ../../tutorial.rst:28
msgid ""
"PyUSB supports isochronous transfers if the underlying backend supports "
"it."
msgstr ""
"基礎となるバックエンドがアイソクロナス転送(isochronous "
"transfers)をサポートしている場合、PyUSBはアイソクロナス(isochronous transfers)転送をサポートします。"

#: ../../tutorial.rst:30
msgid ""
"Although PyUSB makes USB programming less painful, it is assumed in this "
"tutorial that you have a minimal USB protocol background. If you don't "
"know anything about USB, I recommend you the excellent Jan Axelson's book"
" **USB Complete**."
msgstr "PyUSBはUSBプログラミングの苦痛を軽減しますが、このチュートリアルでは、最小限のUSBプロトコルの予備知識があることを前提としています。 USBについて何も知らない場合は、優れたJan Axelsonの著書 **USB Complete** をお勧めします。(訳注: USB Complete: The Developer's Guide (Complete Guides series) (English Edition) https://www.amazon.co.jp/dp/B00U58R0FA/ 日本語版もあるが版数が古そう)"

#: ../../tutorial.rst:36
msgid "Enough talk, let's code!"
msgstr "もうお話は充分、さぁコーディングしましょう！"

#: ../../tutorial.rst:39
msgid "Who's who"
msgstr "紳士録"

#: ../../tutorial.rst:41
msgid ""
"First of all, let's give an overview on the PyUSB modules. PyUSB modules "
"are under the ``usb`` package, with the following modules:"
msgstr "まず、PyUSBモジュールの概要を説明します。 PyUSBモジュールは ``usb`` パッケージの下にあり、以下のモジュールがあります:"

#: ../../tutorial.rst:45
msgid "Content"
msgstr "モジュール"

#: ../../tutorial.rst:45
msgid "Description"
msgstr "説明"

#: ../../tutorial.rst:47
msgid "core"
msgstr "core"

#: ../../tutorial.rst:47
msgid "The main USB module."
msgstr "メイン USB モジュール。"

#: ../../tutorial.rst:48
msgid "util"
msgstr "util"

#: ../../tutorial.rst:48
msgid "Utility functions."
msgstr "ユーティリティ関数。"

#: ../../tutorial.rst:49
msgid "control"
msgstr "control"

#: ../../tutorial.rst:49
msgid "Standard control requests."
msgstr "Standard control requests."

#: ../../tutorial.rst:50
msgid "legacy"
msgstr "legacy"

#: ../../tutorial.rst:50
msgid "The 0.x compatibility layer."
msgstr "バージョン 0.x 系 互換レイヤ。"

#: ../../tutorial.rst:51
msgid "backend"
msgstr "backend"

#: ../../tutorial.rst:51
msgid "A subpackage containing the builtin backends."
msgstr "組み込みのバックエンドを含むサブパッケージ。"

#: ../../tutorial.rst:54
msgid "For example, to import the ``core`` module, type the following::"
msgstr "たとえば、coreモジュールをインポートするには、次のように入力します::"

#: ../../tutorial.rst:60
msgid "Let's get it started"
msgstr "それじゃあ初めましょう"

#: ../../tutorial.rst:62
msgid ""
"Following is a simplistic program that sends the 'test' string to the "
"first OUT endpoint found:"
msgstr "以下は、見つかった最初のOUTエンドポイント(OUT endpoint)に 'test' 文字列を送信する単純際まわりないプログラムです:"

#: ../../tutorial.rst:98
msgid ""
"The first two lines import PyUSB package modules. ``usb.core`` is the "
"main module, and ``usb.util`` contains utility functions. The next "
"command searches for our device and returns an instance object if it is "
"found. If not, ``None`` is returned.  After, we set the configuration to "
"use. Note that no argument indicating what configuration we want was "
"supplied. As you will see, many PyUSB functions have defaults for most "
"common devices. In this case, the configuration set is the first one "
"found."
msgstr "最初の2行でPyUSBパッケージモジュールをインポートします。 ``usb.core`` がメインモジュールで、 ``usb.util`` はユーティリティ関数です。その次の命令はデバイスを検索し、見つかった場合はインスタンスオブジェクトを返します。 なければ ``None`` が返されます。その後、使用する構成(configuration)を設定します。必要な構成(configuration)を示す引数が指定されていないことに注意してください。 ご覧のとおり、多くのPyUSB関数には、ほとんどの一般的なデバイスのデフォルトがあります。この場合、その構成セット(configuration set)は最初に見つかったものです。"

#: ../../tutorial.rst:106
msgid ""
"Then, we look for the endpoint we are interested. We search for it inside"
" the first interface we have. After finding the endpoint, we send the "
"data to it."
msgstr "次に、私たちが関心のあるエンドポイント(endpoint)を探します。 私たちは最初のインターフェース(interface)内で検索します。 エンドポイント(endpoint)を見つけたら、データをエンドポイント(endpoint)に送信します。"

#: ../../tutorial.rst:109
msgid ""
"If we know the endpoint address in advance, we could just call the "
"``write`` function from the device object:"
msgstr "私たちがエンドポイントアドレス(endpoint address)を事前に知っている場合は、デバイス(device)オブジェクトから ``write`` 関数を呼び出すだけです。"

#: ../../tutorial.rst:116
msgid ""
"Here we write the string 'test' at the endpoint address *1*. All these "
"functions will be detailed in the following sections."
msgstr "ここでは、私たちはエンドポイントアドレス(endpoint address) *1* に文字列 'test' を書き込みます。 これらすべての機能については、次節で詳しく説明します。"

#: ../../tutorial.rst:120
msgid "What's wrong?"
msgstr "問題は何？"

#: ../../tutorial.rst:122
msgid ""
"Every function in PyUSB raises an exception in case of an error. Besides "
"the `Python standard exceptions "
"<http://docs.python.org/library/exceptions.html>`__, PyUSB defines the "
"``usb.core.USBError`` for USB related errors."
msgstr ""
"エラー発生時、PyUSBの全ての関数は1つの例外を発生させます。`Python標準例外 "
"<http://docs.python.org/library/exceptions.html>`__ に加えて、PyUSBはUSB関連エラーの "
"``usb.core.USBError`` を定義しています。"

#: ../../tutorial.rst:127
msgid ""
"You can also use the PyUSB log functionality. It uses the `logging "
"<http://docs.python.org/library/logging.html>`__ module. To enable it, "
"define the environment variable ``PYUSB_DEBUG`` with one of the following"
" level names: ``critical``, ``error``, ``warning``, ``info`` or "
"``debug``."
msgstr ""
"あなたはPyUSBログ機能を使用することもできます。 `logging "
"<http://docs.python.org/library/logging.html>`__ モジュールを使用します。 "
"これを有効にするには、環境変数 ``PYUSB_DEBUG`` をレベル名 ``critical``、 ``error``、 "
"``warning``、``info``、 ``debug`` のいずれかで定義します。"

#: ../../tutorial.rst:132
msgid ""
"By default the messages are sent to `sys.stderr "
"<http://docs.python.org/library/sys.html>`__.  If you want to, you can "
"redirect log messages to a file by defining the ``PYUSB_LOG_FILENAME`` "
"environment variable. If its value is a valid file path, messages will be"
" written to it, otherwise it will be sent to ``sys.stderr``."
msgstr ""
"デフォルトでは、メッセージは `sys.stderr <http://docs.python.org/library/sys.html>`__ "
"に送信されます。 必要に応じて、 ``PYUSB_LOG_FILENAME`` "
"環境変数を定義することで、ログメッセージをファイルにリダイレクトできます。 "
"その値が有効なファイルパスである場合、メッセージはそれに書き込まれ、そうでない場合は、 ``sys.stderr`` に送信されます。"

#: ../../tutorial.rst:139
msgid "Where are you?"
msgstr "あなたはそこにいますか？"

#: ../../tutorial.rst:141
msgid ""
"The ``find()`` function in the ``core`` module is used to find and "
"enumerate devices connected to the system. For example, let's say that "
"our device has a vendor ID equal to `0xfffe` and product ID equals to "
"`0x0001`. If we would like to find it, we proceed in this way:"
msgstr ""
"``core`` モジュールの ``find()`` 関数は、システムに接続されたデバイスを見つけて列挙するために使用されます。 "
"たとえば、デバイスのvendor ID(ベンダーID)が `0xfffe` 、 product ID(製品ID)が `0x0001` "
"であるとします。 それを探したい場合は、次のように進めます:"

#: ../../tutorial.rst:154
msgid ""
"That's it, the function will return an ``usb.core.Device`` object "
"representing our device. If the device is not found, it returns ``None``."
" Actually, you can use any field of the Device Descriptor_ you desire. "
"For example, what if we would like to discover if there is a USB printer "
"connected to the system?  This is very easy:"
msgstr ""
"以上で、関数はデバイスを表す ``usb.core.Device`` オブジェクトを返します。 デバイスが見つからない場合、 ``None`` "
"を返します。 実際には、デバイス・デスクリプタ( Device Descriptor_ )の任意のフィールドを使用できます。 "
"たとえば、システムにUSBプリンターが接続されているかどうかを確認するにはどうすればよいでしょうか。 これはとても簡単です:"

#: ../../tutorial.rst:166
msgid ""
"The 7 is the code for the printer class according to the USB spec. Hey, "
"wait, what if I want to enumerate all printers present? No problem:"
msgstr "7は、USB仕様によるプリンタークラスのコードです。 ちょっと待てや！存在するすべてのプリンターを列挙したい場合はどうなりますか？問題ありません:"

#: ../../tutorial.rst:178
msgid ""
"What happened? Well, it is time for a little explanation... ``find`` has "
"a parameter called ``find_all`` that defaults to False. When it is false "
"[#]_, ``find`` will return the first device found that matches the "
"specified criteria (more on that soon). If you give it a *true* value, "
"``find`` will instead return an iterator of all devices that match the "
"criteria.  That's it! Simple, isn't it?"
msgstr "何が起きたのでしょう？ 少々説明する時がきたようです。 ``find`` には ``find_all`` というパラメータがあり、デフォルトはFalseです。 false [#]_ の場合、 ``find`` は指定された基準に一致する最初に見つかったデバイスを返します(詳細はもうちょい後で)。 もしあなたが *true* の値を与えると、 ``find`` は代わりに基準に一致するすべてのデバイスのイテレータを返します。 以上です！簡単でしょ？"

# プログラマの三大美徳のうちの一つ「怠惰」を指定しているっぽい。どこにリンクするかな？
#: ../../tutorial.rst:185
msgid ""
"Finished? No! I have not told you the whole history: many devices "
"actually put their class information in the Interface Descriptor_ instead"
" of the Device Descriptor_. So, to really find all printers connected to "
"the system, we would need to transverse all configurations, and then all "
"interfaces and check if one of the interfaces has its `bInterfaceClass` "
"field equal to 7. If you are a `programmer "
"<http://en.wikipedia.org/wiki/Laziness>`__ like me, you might be "
"wondering if there is an easier way to do that. The answer is yes, there "
"is. First, let's give a look on the final code to find all printers "
"connected:"
msgstr ""
"これで終わり？いいえ。私はあなたにすべての歴史を話したわけではありません。多くのデバイスは実際にはクラス情報をデバイス・デスクリプタ( "
"Device Descriptor_ )ではなくインターフェイス・デスクリプタ( Interface Descriptor_ )に入れます。 "
"したがって、システムに接続されているすべてのプリンターを本当に見つけるには、すべての構成、次にすべてのインターフェイスを渡り歩き、いずれかのインターフェイスの"
" `bInterfaceClass` フィールドが7に等しいかどうかを確認する必要があります。  私のような `プログラマー "
"<http://en.wikipedia.org/wiki/Laziness>`__ なら、もっと簡単な方法があるのか疑問に思うでしょう。 "
"もちろん答えはYES。 まず、接続されているすべてのプリンターを見つけるための最終的なコードを見てみましょう。"

#: ../../tutorial.rst:222
msgid ""
"The ``custom_match`` parameter accepts any callable object that receives "
"the device object. It must return true for a matching device, and false "
"for a non-matching device. You can also combine ``custom_match`` with "
"device fields if you want:"
msgstr ""
"``custom_match`` "
"パラメータは、デバイスオブジェクトを受け取る呼び出し可能なオブジェクトを受け入れます。一致するデバイスの場合はtrueを返し、一致しないデバイスの場合はfalseを返す必要があります。"
" 必要に応じて、 ``custom_match`` とデバイスフィールドを組み合わせることもできます:"

#: ../../tutorial.rst:232
msgid "Here we are only interested in the printers of the `0xfffe` vendor."
msgstr "今ここでは、`0xfffe` ベンダーのプリンターのみに関心があります。"

#: ../../tutorial.rst:235
msgid "Describe yourself"
msgstr "お主、何者じゃ！"

#: ../../tutorial.rst:237
msgid ""
"Ok, we've found our device, but before talking to it, we would like to "
"know more about it, you know, configurations, interfaces, endpoints, "
"transfer types..."
msgstr "やった！デバイスを見つけました。が、そのデバイス君とお話をする前に、構成、インターフェース、エンドポイント、転送タイプなどについて詳しく知りたいと思います…"

#: ../../tutorial.rst:241
msgid ""
"If you have a device, you can access any device descriptor fields as "
"object properties:"
msgstr "あなたがデバイスを持っている場合は、あなたはオブジェクトのプロパティとして任意のデバイス・デスクリプタ・フィールドにアクセスできます:"

#: ../../tutorial.rst:251
msgid ""
"To access the configurations available in the device, you can iterate "
"over the device:"
msgstr "デバイスで有効な構成にアクセスするときは、あなたはデバイスを反復処理(iterate)できます:"

#: ../../tutorial.rst:259
msgid ""
"In the same way, you can iterate over a configuration to access the "
"interfaces, and iterate over the interfaces to access their endpoints. "
"Each kind of object has as attributes the fields of the respective "
"descriptor. Let's see an example:"
msgstr ""
"同様に、構成を反復(iterate)してインターフェイスにアクセスしたり、インターフェイスを反復(iterate)してエンドポイントにアクセスしたりできます。"
" 各種類のオブジェクトには、それぞれのデスクリプタのフィールドが属性として含まれています。 例を見てみましょう:"

#: ../../tutorial.rst:279
msgid ""
"You can also use the subscript operator to access the descriptors "
"randomly, like this:"
msgstr "次のように、添え字を使用してデスクリプタにランダムにアクセスすることもできます:"

#: ../../tutorial.rst:291
msgid ""
"As you can see, the index is zero-based. But wait! There is something "
"weird in the way I access an interface... Yes, you are right, the "
"subscript operator in the Configuration accepts a sequence of two items, "
"with the first one being the index of the Interface and the second one, "
"the alternate setting. So, to access the first interface, but its second "
"alternate setting, we write ``cfg[(0,1)]``."
msgstr ""
"ご覧のとおり、インデックスはゼロベースです。 ちょっと待って！ "
"私がインターフェイスにアクセスする方法に奇妙な点があります…はい、そうです、構成の添え字は2つのアイテムのシーケンスを受け入れます。最初のアイテムはインターフェイスのインデックスで、2番目のアイテムは代替設定です。したがって、最初のインターフェイスにアクセスするが、2番目の代替設定には、"
" ``cfg[(0,1)]`` と書き込みます。"

#: ../../tutorial.rst:297
msgid ""
"Now it's time to we learn a powerful way to find descriptors, the "
"``find_descriptor`` utility function. We have already seen it in the "
"printer finding example.  ``find_descriptor`` works in almost the same "
"way as ``find``, with two exceptions:"
msgstr ""
"それでは、デスクリプタを見つける強力な方法である ``find_descriptor`` ユーティリティ関数について学びましょう。 "
"私たちはプリンター検索の例でそれをすでに見ています。 ``find_descriptor`` は ``find`` "
"とほぼ同じように動作しますが、2つの例外があります:"

#: ../../tutorial.rst:302
msgid ""
"``find_descriptor`` receives as its first parameter the parent descriptor"
" that you will search on."
msgstr "``find_descriptor`` は、最初のパラメータとして、あなたが検索したいデスクリプタの親デスクリプタを受け取ります。"

#: ../../tutorial.rst:304
msgid "There is no ``backend`` [#]_ parameter."
msgstr "``backend`` [#]_ パラメータはありません。"

#: ../../tutorial.rst:306
msgid ""
"For example, if we have a configuration descriptor ``cfg`` and want to "
"find all alternate settings of the interface 1, we do so:"
msgstr "たとえば、構成デスクリプタ ``cfg`` があり、インターフェース1のすべての代替設定を検索したい場合は、次のようにします:"

#: ../../tutorial.rst:314
msgid ""
"Notice that ``find_descriptor`` is in the ``usb.util`` module. It also "
"accepts the early described ``custom_match`` parameter."
msgstr ""
"``find_descriptor`` は ``usb.util`` モジュールにあることに注意してください。 また、前述の "
"``custom_match`` パラメータも受け入れます。"

#: ../../tutorial.rst:318
msgid "Dealing with multiple identical devices"
msgstr "同じデバイスを複数扱うには"

#: ../../tutorial.rst:320
msgid ""
"Sometimes you may have two identical devices connected to the computer. "
"How can you differentiate them? ``Device`` objects come with two "
"additional attributes which are not part of the USB Spec, but are very "
"useful: ``bus`` and ``address`` attributes. First of all, it is worth it "
"to say that these attributes come from the backend and a backend is free "
"to not support them, in which case they are set to ``None``. That said, "
"these attributes represent the bus number and bus address of the device "
"and, as you might already have imagined, can be used to differentiate two"
" devices with the same ``idVendor`` and ``idProduct`` attributes."
msgstr ""
"コンピューター同じデバイスが2接続されていることがあります。それらをどのように区別すればよいでしょうか？ ``Device`` "
"オブジェクトには、USB仕様の一部ではないが、非常に便利な2つの追加属性があります。それは ``bus`` と ``address`` 属性です。"
"\n"
"ただし、これらの属性はバックエンドからのものであり、バックエンドがそれらをサポートしないことは自由です。その場合、それらは ``None`` "
"に設定されます。そうじゃない場合は、これらの属性はデバイスのバス番号とバスアドレスを表し、あなたのご想像どおり、同じ ``idVendor`` と"
" ``idProduct`` 属性を持つ2つのデバイスを区別するために使用できます。"

#: ../../tutorial.rst:331
msgid "How am I supposed to work?"
msgstr "私はどのようにすればいいですか？"

#: ../../tutorial.rst:333
msgid ""
"USB devices after connection must be configured through a few standard "
"requests.  When I started to study USB_ spec, I found myself confused "
"with descriptors, configurations, interfaces, alternate settings, "
"transfer types and all this stuff... And worst, you cannot simply ignore "
"them, a device does not work without setting a configuration, even if it "
"has just one! PyUSB tries to make your life as easy as possible. For "
"example, after getting your device object, one of the first things you "
"need to do before communicating with it is issuing a "
"``set_configuration`` request. The parameter for this request is the "
"``bConfigurationValue`` of the configuration you are interested on.  Most"
" devices have no more than one configuration, and tracking the "
"configuration value to use is annoying (although most code I have seen "
"simply hardcodes it). Therefore, in PyUSB, you can just issue a "
"``set_configuration`` call with no arguments. In this case, it will set "
"the first configuration found (if your device has just one, you don't "
"need to worry about the configuration value at all). For example, let's "
"imagine you have a device with one configuration descriptor with its "
"`bConfigurationValue` field equals to 5 [#]_, the following calls below "
"will work equally:"
msgstr ""
"接続されたUSBデバイスは、いくつかの標準的なリクエストを使って構成する必要があります。私は USB_ "
"仕様の調査を始めたとき、デスクリプタ(descriptors)、構成(configurations)、インターフェイス(interfaces)、代替設定(alternate"
" settings)、転送タイプ(trannsfer "
"types)、その他もろもろで混乱していました。そして最悪なことに、たったひとつの構成設定でも無視したら動かないのです。 "
"PyUSBはあなたがこれをできるだけ簡単にできるようにすることを目指します。たとえば、デバイス・オブジェクトを取得した後、それと通信する前に最初に行う必要があることの1つは、"
"  ``set_configuration`` リクエストを発行することです。\n"
"このリクエストのパラメータは、あなたが関心のある構成(configuration)にある ``bConfigurationValue`` です。 "
"ほとんどのデバイスには構成(configuration)が1つしかなく、使用する構成値を追跡するのは面倒です(私が見たほとんどは単純にハードコーディングしています)。それゆえ"
" PyUSBでは、あなたが引数なしで ``set_configuration`` を呼び出すだけで済むようにしてあります。 "
"この場合、最初に見つかった構成(configuration)が設定されます(デバイスに1つしかない場合は、その構成値を気にする必要はありません)。"
" たとえば、 `bConfigurationValue` フィールドが5 [#]_ "
"に等しい構成(configuration)デスクリプタが1つあるデバイスがあるとします。以下の呼び出しはいずれも同様に機能します:"

#: ../../tutorial.rst:363
msgid ""
"Wow! You can use a ``Configuration`` object as a parameter to "
"``set_configuration``!  Yes, and also it has a ``set`` method to "
"configure itself as the current configuration."
msgstr ""
"えっへん！ ``Configuration`` オブジェクトを ``set_configuration`` のパラメータとして使用できます！ "
"はい、そしてそれ自身を当座(current)の構成(configuration)として設定するための ``set`` メソッドもあります。"

#: ../../tutorial.rst:367
msgid ""
"The other setting you might or might not have to configure is the "
"interface alternate setting. Each device can have only one activated "
"configuration at a time, and each configuration may have more than one "
"interface, and you can use all interfaces at the same time. You better "
"understand this concept if you think of an interface as a logical device."
" For example, let's imagine a multifunction printer, which is at the same"
" time a printer and a scanner. To keep things simple (or at least as "
"simple as we can), let's consider that it has just one configuration. As "
"we have a printer and a scanner, the configuration has two interfaces, "
"one for the printer and one for the scanner. A device with more than one "
"interface is called a composite device. When you connect your "
"multifunction printer to your computer, the Operating System would load "
"two different drivers: one for each \"logical\" peripheral you have [#]_."
msgstr ""
"構成する必要がある場合と必要ない場合があるもう1つの設定は、インターフェイスの代替設定です。各デバイスは一度に1つのアクティブ化された構成(configration)のみを持つことができ、各構成(configuration)には複数のインターフェイスがあり、すべてのインターフェイスを同時に使用できます。"
" インターフェイスを論理デバイスと考えると、この概念をよりよく理解できます。 "
"たとえば、多機能プリンターを想像してみましょう。これは同時にプリンターとスキャナーです。 "
"物事をシンプルに(または少なくともできるだけシンプルに)保つために、構成(configuration)が1つしかないと考えてみましょう。 "
"プリンターとスキャナーがあるため、構成には2つのインターフェースがあり、1つはプリンター用、もう1つはスキャナー用です。 "
"複数のインターフェースを持つデバイスは、複合デバイスと呼ばれます。 "
"多機能プリンターをコンピューターに接続すると、オペレーティングシステムは2つの異なるドライバーをロードします。すなわち、あなたがお持ちの「論理」機器ごとに1つです。"
" [#]_ "

#: ../../tutorial.rst:380
msgid ""
"What about the alternate setting? Good you asked. An interface has one or"
" more alternate settings. An interface with just one alternate setting is"
" considered to not having an alternate setting [#]_. Alternate settings "
"are for interfaces what configurations are for devices, i.e, for each "
"interface, you can have only one alternate setting active. For example, "
"USB spec says that a device cannot have an isochronous endpoint in its "
"primary alternate setting [#]_, so a streaming device must have at least "
"two alternate settings, with the second one having the isochronous "
"endpoint(s). But as opposed to configurations, interfaces with just one "
"alternate setting don't need to be set [#]_. You select an interface "
"alternate setting through the ``set_interface_altsetting`` function:"
msgstr ""
"じゃあ代替設定(alternate setting)の方はどうなの？ ええ、インターフェイスには1つ以上の代替設定があります。 "
"代替設定が1つしかないインターフェイスは、代替設定がないと見なされます( [#]_ )。 代替設定(alternate "
"setting)はインターフェイス用であり、構成(configuration)はデバイス用です。つまり、各インターフェイス対して、アクティブにできる代替設定(alternate"
" setting)は1つだけです。 たとえば、USB仕様では、デバイスのプライマリ代替設定(alternate "
"setting)にアイソクロナス・エンドポイント(isochronous endpoint)を含めることはできないため( [#]_ ) "
"、ストリーミングデバイスには少なくとも2つの代替設定(alternate "
"setting)が必要で、2番目の設定にはアイソクロナス・エンドポイント(isochronous endpoint)があります。 "
"ただし、構成(configuration)とは異なり、代替設定(alternate "
"setting)が1つだけのインターフェイスを設定する必要はありません( [#]_ )。 ``set_interface_altsetting``"
" 関数でインターフェイスの代替設定(alternate setting)を選択します:"

#: ../../tutorial.rst:397
msgid ""
"The USB spec says that a device is allowed to return an error in case it "
"receives a SET_INTERFACE request for an interface that has no additional "
"alternate settings. So, if you are not sure if either the interface has "
"more than one alternate setting or it accepts a SET_INTERFACE request, "
"the safest way is to call ``set_interface_altsetting`` inside an try-"
"except block, like this:"
msgstr ""
"USB仕様では、追加の代替設定(alternate "
"settings)のないインターフェイスに対するSET_INTERFACEリクエストを受信した場合、デバイスはエラーを返すことが許可されているとされています。したがって、インターフェースに複数の代替設定(alternate"
" settings)があるか、またはSET_INTERFACEリクエストを受け入れるかどうか不明な場合は、次のようにtry-"
"exceptブロック内で ``set_interface_altsetting`` を呼び出すのが最も安全な方法です:"

#: ../../tutorial.rst:411
msgid ""
"You can also use an ``Interface`` object as parameter to the function, "
"the ``interface`` and ``alternate_setting`` parameters are automatically "
"inferred from ``bInterfaceNumber`` and ``bAlternateSetting`` fields. "
"Example:"
msgstr ""
"あなたは関数のパラメータとして ``Interface`` オブジェクトを使用することもでき、 その際、 ``interface`` と "
"``alternate_setting`` パラメータは ``bInterfaceNumber`` と ``bAlternateSetting``"
" フィールドから自動的に推論されます。 例えば:"

#: ../../tutorial.rst:422
msgid ""
"The ``Interface`` object must belong to the active configuration "
"descriptor."
msgstr "その ``Interface`` オブジェクトはアクティブな構成(configuration)デスクリプタに属している必要があります。"

#: ../../tutorial.rst:425
msgid "Talk to me, honey"
msgstr "私とお話して頂戴"

#: ../../tutorial.rst:427
msgid ""
"Now it's time for us to learn how to communicate with USB devices. USB "
"has four flavors of transfers: bulk, interrupt, isochronous and control. "
"I don't intend to explain the purpose of each transfer and the "
"differences among them. Therefore, I assume you know at least the basics "
"of the USB transfers."
msgstr ""
"いよいよUSBデバイスと通信する方法を学ぶ時が来ました。 "
"USBには、バルク(bulk)と割り込み(interrupt)とアイソクロナス(isochronous)と制御(control)の、4種類の転送方法があります。"
" 私は各転送方法の目的とそれらの間の違いを説明するつもりはありません。私は、あなたが少なくともUSB転送の基本を知っているものとして扱います。"

#: ../../tutorial.rst:432
msgid ""
"Control transfer is the only transfer that has structured data described "
"in the spec, the others just send and receive raw data from USB point of "
"view. Because of it, you have a different function to deal with control "
"transfers, all the other transfers are managed by the same functions."
msgstr ""
"制御(control)転送は、仕様に記載されている構造化データを持つ唯一の転送です。他の転送は、USBの観点からは生データを送受信するだけです。 "
"そのため、制御(control)転送を処理するためだけに別の関数があり、他のすべての転送は同じ関数によって管理されます。"

#: ../../tutorial.rst:437
msgid ""
"You issue a control transfer through the ``ctrl_transfer`` method. It is "
"used both for OUT and IN transfers. The transfer direction is determined "
"from the ``bmRequestType`` parameter."
msgstr ""
"あなたは ``ctrl_transfer`` "
"メソッドを介して制御(control)転送を発行します。それはOUT転送とIN転送の両方に使用されます。転送方向は "
"``bmRequestType`` パラメータによって決定されます。"

#: ../../tutorial.rst:441
msgid ""
"The ``ctrl_transfer`` parameters are almost equal to the control request "
"structure. Following is a example of how to do a control transfer [#]_:"
msgstr ""
"``ctrl_transfer`` パラメータは制御要求構造(control request structure)とほとんど同じです。 "
"以下は、制御(control)転送を行う方法の例です([#]_):"

#: ../../tutorial.rst:452
msgid ""
"In this example, it is assumed that our device implements two custom "
"control requests that act as a loopback pipe. What you write with the "
"``CTRL_LOOPBACK_WRITE`` message, you can read with the "
"``CTRL_LOOPBACK_READ`` message."
msgstr ""
"この例では、デバイスがループバック・パイプとして機能する2つのカスタム制御要求(custom control "
"request)を実装していると想定しています。 ``CTRL_LOOPBACK_WRITE`` メッセージで書き込んだものは、 "
"``CTRL_LOOPBACK_READ`` メッセージで読み取ることができます。"

#: ../../tutorial.rst:457
msgid ""
"The first four parameters are the ``bmRequestType``, ``bmRequest``, "
"``wValue`` and ``wIndex`` fields of the standard control transfer "
"structure. The fifth parameter is either the data payload for an OUT "
"transfer or the number of bytes to read in an IN transfer.  The data "
"payload can be any sequence type that can be used as a parameter for the "
"array_ ``__init__`` method.  If there is no data payload, the parameter "
"should be ``None`` (or 0 in case of an IN transfer). There is one last "
"optional parameter specifying the timeout of the operation. If you don't "
"supply it, a default timeout will be used (more on that later). In an OUT"
" transfer, the return value is the number of bytes really sent to the "
"device. In an IN transfer, the return value is an array_ object with the "
"data read."
msgstr ""
"最初の4つのパラメータは、標準制御転送構造(standard control transfer)のフィールド ``bmRequestType``、"
" ``bmRequest``、 ``wValue``、 ``wIndex`` です。 "
"5番目のパラメーター(訳注:data_or_wLength=None)は、OUT転送のデータ・ペイロード、またはIN転送で読み取るバイト数です。 "
"データペイロードは、array_ ``__init__`` メソッドのパラメーターとして使用できる任意のシーケンス型にすることができます。 "
"データ・ペイロードがない場合、パラメータは  ``None`` (またはIN転送の場合は0)でなければなりません。 "
"操作のタイムアウトを指定する最後のオプションパラメータ(訳注:timeout=None)が1つあります。 "
"指定しない場合は、デフォルトのタイムアウトが使用されます(詳しくは後で説明します)。 "
"OUT転送では、戻り値は実際にデバイスに送信されたバイト数です。IN転送では、戻り値はデータが読み込まれた array_ オブジェクトです。"

#: ../../tutorial.rst:469
msgid ""
"For the other transfers, you use the methods ``write`` and ``read``, "
"respectively, to write and read data. You don't need to worry about the "
"transfer type, it is automatically determined from the endpoint address. "
"Here is our loopback example assuming the we have a loopback pipe in the "
"endpoint 1:"
msgstr ""
"他の転送については、メソッド ``write`` と ``read`` "
"を使用して、データの書き込みと読み取りを行います。転送タイプを気にする必要はありません。転送タイプはエンドポイント・アドレスから自動的に決定されます。エンドポイント1にループバック・パイプがあると想定したループバックの例を以下に示します:"

#: ../../tutorial.rst:483
msgid ""
"The first and third parameters are equal for both methods, they are the "
"endpoint address and timeout, respectively. The second parameter is the "
"data payload (write) or the number of bytes to read (read). The returned "
"data if either an instance of the array_ object for the ``read`` method "
"or the number of bytes written for the ``write`` method."
msgstr ""
"最初(endpoint)と3番目(timeout)のパラメーターはread/write両方のメソッドで等しくそれぞれエンドポイント・アドレスとタイムアウトです。"
" 2番目のパラメーターは、データ・ペイロード(write)または読み取るバイト数(read)です。 ``read`` メソッドの戻り値は "
"array_ オブジェクトのインスタンスで、``write`` メソッドの戻り値はで書き込んだバイト数です。"

#: ../../tutorial.rst:489
msgid ""
"Since beta 2 version, instead of the number of bytes, you can also pass "
"to ``read`` and ``ctrl_transfer`` an array_ object in which the data will"
" be read into. In this case, the number of bytes to read will be the "
"length of the array times the ``array.itemsize`` value."
msgstr ""
"ベータ2バージョン以降、バイト数の代わりに、データが読み込まれる array_ オブジェクトを ``read`` と "
"``ctrl_transfer`` に渡すこともできます。 この場合、読み込むバイト数は、配列の長さと ``array.itemsize`` "
"値の積になります。"

#: ../../tutorial.rst:494
msgid ""
"As in ``ctrl_transfer``, the ``timeout`` parameter is optional. When the "
"``timeout`` is omitted, it is used the ``Device.default_timeout`` "
"property as the operation timeout."
msgstr ""
"``ctrl_transfer`` と同様に、 ``timeout`` パラメータはオプションです。 ``timeout`` "
"が省略された場合、操作のタイムアウト値として ``Device.default_timeout`` プロパティが使用されます。"

#: ../../tutorial.rst:499
msgid "Control yourself"
msgstr "自分自身を制御する"

#: ../../tutorial.rst:501
msgid ""
"Besides the transfers functions, the module ``usb.control`` offers "
"functions which implement the standard USB control requests and the "
"``usb.util`` module has the convenience function ``get_string`` "
"specifically to return string descriptors."
msgstr ""
"転送関数に加えて、モジュール ``usb.control`` は、標準のUSB制御要求(standard USB control "
"request)を実装する関数を提供し、 ``usb.util`` モジュールには、文字列デスクリプタを返すための便利な関数 "
"``get_string`` があります。"

#: ../../tutorial.rst:507
msgid "Additional Topics"
msgstr "オマケ"

#: ../../tutorial.rst:510
msgid "Behind every great abstraction, there's a great implementation"
msgstr "優れた抽象化の背後には、優れた実装があります"

#: ../../tutorial.rst:512
msgid ""
"In the early days, there was only libusb_. Then came libusb 1.0, and we "
"had libusb 0.1 and 1.0.  After, they created OpenUSB_, and now we live at"
" the `Tower of Babel <http://en.wikipedia.org/wiki/Tower_of_Babel>`__ of "
"the USB libraries [#]_.  How does PyUSB deal with it? Well, PyUSB is a "
"democratic library, you may choose whichever library you want. Actually, "
"you can write your own USB library from scratch and tell PyUSB to use it."
" But you are probably better sticking with libusb 1.0."
msgstr ""
"初期の頃は libusb_ しかありませんでした。次にlibusb 1.0が登場し、libusb 0.1と1.0がリリースされました。 "
"その後、OpenUSB_ が開発され、現在私たちは、USBライブラリのバベルの塔( `Tower of Babel "
"<http://en.wikipedia.org/wiki/Tower_of_Babel>`__ )に住んでいます([#]_) 。 "
"PyUSBはそれをどのように扱いますか？ ええ、PyUSBは民主的なライブラリです。あなたは好きなライブラリを選択できます。 "
"実際、独自のUSBライブラリを最初から作成して、PyUSBに使用するように指示することができます。 しかし、あなたはたぶんlibusb "
"1.0を使用するのがいいでしょう。"

#: ../../tutorial.rst:520
msgid ""
"The ``find`` function has one more parameter that I haven't told you. It "
"is the ``backend`` parameter. If you don't supply it, it will be used one"
" of the builtin backends. A backend is an object inherited from "
"``usb.backend.IBackend``, responsible to implement the operating system "
"specific USB stuff. As you might guess, the builtins are libusb 1.0 "
"(default), libusb 0.1 and OpenUSB (deprecated) backends."
msgstr ""
"``find`` 関数には、まだ説明していないパラメータがあります。これは ``backend`` パラメータです。 "
"指定しない場合は、組み込みのバックエンドの1つが使用されます。 バックエンドは ``usb.backend.IBackend`` "
"から継承されたオブジェクトで、オペレーティング・システム固有のUSBの実装を担当します。ご想像のとおり、既にPyUSBに組み込み済なのはlibusb"
" 1.0(デフォルト)とlibusb 0.1とOpenUSB(非推奨)バックエンドです。"

#: ../../tutorial.rst:527
msgid ""
"You can create your own backend and use it. Just inherit from "
"``IBackend`` and implement the methods necessary. You might want to take "
"a look at the ``usb.backend`` package documentation to learn how to do "
"that."
msgstr ""
"あなたは独自のバックエンドを作成・使用することができます。 ``IBackend`` から継承し、必要なメソッドを実装するだけです。 "
"方法については、 ``usb.backend`` パッケージのドキュメントをご覧ください。"

#: ../../tutorial.rst:532
msgid "Don't be selfish"
msgstr "ホンマわがままやなぁ…"

#: ../../tutorial.rst:534
msgid ""
"Python has what we call *automatic memory management*. This means that "
"the virtual machine will decide when to release objects from the memory. "
"Under the hood, PyUSB manages all low level resources it needs to work "
"(interface claiming, device handles, etc.) and most of the users don't "
"need to worry about that. But, because of the nondeterministic nature of "
"automatic object destruction of Python, users cannot predict when the "
"resources allocated will be released. Some applications need to allocate "
"and free the resources deterministically.  For these kind of "
"applications, the ``usb.util`` module has a set of functions to deal with"
" resource management."
msgstr ""
"Pythonには、*自動メモリ管理* (automatic memory management)と呼ばれるものがあります。 "
"これは、仮想マシンがオブジェクトをメモリから解放するタイミングを決定することを意味します。 "
"内部的には、PyUSBは動作する必要のあるすべての低レベルのリソース(インターフェイスの要求、デバイス・ハンドルなど)を管理し、ほとんどのユーザーはそのことを心配する必要はありません。ただし、Pythonのオブジェクトの自動破棄には非決定的(nondetrministic)な性質があるため、ユーザーは割り当てられたリソースがいつ解放されるかを予測できません。一部のアプリケーションは、確定的にリソースを割り当てて解放する必要があります。これらの種類のアプリケーションのために、"
" ``usb.util`` モジュールはリソース管理を扱うための一連の関数を持っています。"

#: ../../tutorial.rst:544
msgid ""
"If you want to claim and release interfaces manually, you may use the "
"``claim_interface`` and ``release_interface`` functions. "
"``claim_interface`` will claim the specified interface if the device has "
"not done it yet. If the device already claimed the interface, it does "
"nothing.  In a similar way, ``release_interface`` will release the "
"specified interface if it is claimed. If the interface is not claimed, it"
" does nothing. You can use manual interface claim to solve the "
"`configuration selection problem "
"<http://libusb.sourceforge.net/api-1.0/libusb_caveats.html#configsel>`__ "
"described in the libusb_ documentation."
msgstr "あなたがインターフェイス(interface)を手動で要求(claim)および解放(release)したい場合、あなたは ``claim_interface`` 関数と ``release_interface`` 関数を使用できます。 ``claim_interface`` は、デバイスが、あなたが指定したインターフェイスをまだ要求していない場合、それを要求します。 デバイスが既にインターフェイスを要求済であある場合は何もしません。 同様に、 ``release_interface`` は、あなたが指定のインターフェイスが既に要求(claim)済の場合、それを解放します。まだインターフェイスが要求されていない場合は何もしません。あなたはこの手動インターフェイス要求(manual interface claim)を使用して、libusb_ のドキュメントに記載されている構成選択の問題( `configuration selection problem <http://libusb.sourceforge.net/api-1.0/libusb_caveats.html#configsel>`__ )を解決できます。"

#: ../../tutorial.rst:554
msgid ""
"If you want to free all resources allocated by the device object "
"(including interfaces claimed), you can use the ``dispose_resources`` "
"function. It releases all resources allocated and puts the device object "
"(but not the device hardware itself) in the state it was at the time when"
" the ``find`` function returned."
msgstr ""
"あなたが、デバイス・オブジェクトによって割り当てられたすべてのリソース(要求済のインターフェースを含む)を解放したい場合は、 "
"``dispose_resources``  関数を使用できます。 "
"割り当てられたすべてのリソースを解放し、デバイス・オブジェクト(デバイス・ハードウェア自体ではない)を、``find`` "
"関数呼び出しから戻ってきた直後の状態にします。"

#: ../../tutorial.rst:561
msgid "Specifying libraries by hand"
msgstr "ライブラリを手動で指定する"

#: ../../tutorial.rst:563
msgid ""
"In general, a backend is an wrapper on a shared library which implements "
"the USB access API.  By default, the backend uses the `find_library() "
"<http://docs.python.org/3/library/ctypes.html#finding-shared-libraries>`_"
" ctypes_ function. On Linux and other Unix like Operating Systems, "
"``find_library`` tries to run external programs (like */sbin/ldconfig*, "
"*gcc* and *objdump*) to find the library file."
msgstr ""
"一般に、バックエンドは、USBアクセスAPIを実装する共有ライブラリのラッパーです。 デフォルトでは、バックエンドは "
"`find_library() <http://docs.python.org/3/library/ctypes.html#finding-"
"shared-libraries>`_ ctypes_ 関数を使用します。 Linuxや他のUNIX風オペレーティングシステムでは、 "
"``find_library`` は外部プログラム( */sbin/ldconfig* や *gcc* や *objdump* "
"など)を実行してライブラリファイルを見つけようとします。"

#: ../../tutorial.rst:570
msgid ""
"On systems where these programs are missing and/or the library cache is "
"disabled, this function cannot be used. To overcome this limitation, "
"PyUSB allows you to supply a custom `find_library()` function to the "
"backend."
msgstr ""
"これらのプログラムがないか、ライブラリ・キャッシュが無効になっているシステムでは、この機能は使用できません。 "
"この制限を克服するために、PyUSBではカスタムの `find_library()` 関数をバックエンドに提供できます。"

#: ../../tutorial.rst:574
msgid "An example for such scenario would be:"
msgstr "このようなシナリオの例です:"

#: ../../tutorial.rst:584
msgid ""
"Notice the `find_library` argument for the `get_backend()` function, in "
"which you supply a function that is responsible to find the correct "
"library for the backend."
msgstr ""
"`get_backend()` 関数の `find_library` "
"引数に注意してください。この引数では、バックエンドの正しいライブラリを見つける責任がある関数を指定します。"

#: ../../tutorial.rst:589
msgid "Old school rules"
msgstr "古臭いルール"

#: ../../tutorial.rst:591
msgid ""
"If you wrote an application using the old PyUSB API (0.whatever), you may"
" be asking yourself if you need to update your code to use the new API. "
"Well, you should, but you don't need to. PyUSB 1.0 comes with the "
"``usb.legacy`` compatibility module. It implements the older API above "
"the new API. \"So, do I have just to replace my ``import usb`` statement "
"with ``import usb.legacy as usb`` to get my application working?\", you "
"ask. The answer is yes, it will work, but you don't have to. If you run "
"your application untouched it will just work, because the ``import usb`` "
"statement will import all public symbols from ``usb.legacy``. If you face"
" a problem, probably you found a bug."
msgstr ""
"あなたが古いPyUSB API(バージョン 0.X "
"系統)を使用してアプリケーションを作成していた場合、新しいAPIを使用するようにコードを更新する必要があるかどうかを悩んでいるかもしれません。まあ、できればそうすべきですが、そうする必要はありません。"
" PyUSB 1.0には ``usb.legacy`` "
"互換モジュールが付属しています。新しいAPIの上に古いAPIを実装します。「では、アプリケーションを機能させるために、``import usb``"
" を ``import usb.legacy as usb`` "
"に置き換えるだけでよいですか？」答えは「はい」です。これでうまくいきますが、でも、これすらも必要はありません。 "
"アプリケーションをそのまま実行すると、 ``usb.legacy`` からすべてのパブリック・シンボルが ``import usb`` "
"ステートメントによってインポートされるため、そのまま機能します。問題が発生した場合は、おそらくあなたは何かしらバグを発見したということです。(訳注:とは言え、互換なのはあくまでPyUSBだけであってPyUSBが参照するPython標準ライブラリが変更になっていることがある。手元ではUSBError.messageをUSBError.strerrorに修正する必要があった。USBErrorがIOErrorを継承しているため。)"

#: ../../tutorial.rst:601
msgid ""
"When I say True or False (capitalized), I mean the respective values of "
"the Python language. And when I say true and false, I mean any expression"
" in Python which evals to true or false."
msgstr "TrueまたはFalse（先頭大文字）とは、Python言語のそういう値を意味します。そして私がtrueやfalseを言うとき、それはtrueとfalseに評価されるPythonのあらゆる表現を意味します。"

#: ../../tutorial.rst:605
msgid "See backend specific documentation."
msgstr "各々のバックエンドのドキュメントを参照してください。"

#: ../../tutorial.rst:607
msgid ""
"USB spec does not impose any sequential value to the configuration value."
" The same is true for interface and alternate setting numbers."
msgstr ""
"USB仕様では、構成(configuration)に順番になるような値を義務付けていません(訳注:次の値が+1で得られると期待するな、飛び飛びバラバラを覚悟せよということ)。"
" インターフェイスと代替設定(alternate setting)番号についても同様です。"

#: ../../tutorial.rst:610
msgid ""
"Actually things are a little more complex, but this simple explanation is"
" enough for us."
msgstr "実際はもう少し複雑ですが、ここでの説明はとしては十分です。"

#: ../../tutorial.rst:613
msgid "I know it sounds weird."
msgstr "私もそれが奇妙に聞こえることは知っています。"

#: ../../tutorial.rst:615
msgid ""
"This is because if there is no bandwidth for isochronous transfer at the "
"device configuration time, the device can be successfully enumerated."
msgstr "これは、デバイスの構成(configuration)時にアイソクロナス転送用の帯域幅がない場合、デバイスを成功裏に列挙できるためです。"

#: ../../tutorial.rst:618
msgid ""
"This does not happen for configurations because a device is allowed to be"
" in an unconfigured state."
msgstr ""
"デバイスは未構成の状態(unconfigured "
"state)であることが許可されているため、これは構成(configration)では発生しません。"

#: ../../tutorial.rst:621
msgid ""
"In PyUSB, control transfers are only issued in the endpoint 0. It's very "
"very very rare a device having an alternate control endpoint (I've never "
"seen such a device)."
msgstr ""
"PyUSBでは、制御(control)転送はエンドポイント0でのみ発行されます。代替制御エンドポイント(alternate control "
"endpoint)を持つデバイスは非常に非常にまれです（私はそのようなデバイスを全く見たことがありません）。"

#: ../../tutorial.rst:625
msgid ""
"It's just a joke, don't take it seriously. Many choices is better than no"
" choice."
msgstr "単なる冗談です。真剣に受け止めないでください。 でも、多くの選択肢は、選択肢がないよりも優れています。"

